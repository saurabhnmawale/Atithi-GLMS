ATITHI GLMS
Guest Lifecycle Management System
Technical Architecture & Stack Specification
Document Version
1.0
PRD Reference
PRD_Atithi_GLMS v2.1
Platform Target
iOS & Android (Offline-first)
Prepared By
Architecture Review
1. Decision Summary
Concern
Decision
Rationale
Cross-platform framework
Flutter (Dart)
Single codebase, lowest maintenance surface
Local database
Drift (ORM over SQLite)
Type-safe, migrated, reactive — handles 2000-guest scale
Excel export
Syncfusion Flutter XlsIO
Only Flutter library supporting merged cells + styled reports
State management
Riverpod
Testable, no global singletons, right complexity level
App architecture
Feature-first + Repository pattern
Navigable for any new developer; business logic out of UI
2. Cross-Platform Framework: Flutter
Flutter is the recommended framework for Atithi GLMS. The decision is driven by the lowest long-term maintenance cost requirement on a greenfield team with no prior platform preference.
2.1 Why Flutter Over Alternatives
Framework
Verdict
Key Reason
Flutter (Dart)
✅ Selected
Single codebase, no JS bridge, stable ecosystem
React Native
❌ Rejected
JS ecosystem churn causes long-term maintenance overhead
Native iOS + Android
❌ Rejected
Two codebases — doubles maintenance cost immediately
Kotlin Multiplatform
❌ Rejected
Immature UI layer, smaller hiring pool
2.2 Flutter Specifics
Dart is a typed language — easier to onboard new developers versus JS
Hot reload significantly accelerates UI iteration across all 15 screens
No JS bridge means no bridge-related performance cliffs on heavy list screens (Guest List: up to 2000 rows)
Single build pipeline outputs both iOS and Android artifacts
3. Local Database: Drift (SQLite ORM)
All data is stored locally on-device with no backend. The database layer must handle complex relational queries across Events, Hotels, Rooms, Guests, StaySegments, ServiceCharges, and Bills.
3.1 Why Drift Over Raw SQLite
Type-safe query generation catches schema errors at compile time, not runtime
Built-in migration manager — schema changes across app versions are handled without data loss
Reactive streams allow the dashboard and guest list to update automatically when data changes
DAO (Data Access Object) pattern maps cleanly to the repository architecture
3.2 Schema Design
Table
Key Columns
Notes
events
id, name, type, start_date, end_date
Root entity; all data scoped to event
hotels
id, event_id, name
Multiple per event
rooms
id, hotel_id, number, category, status
status: available | occupied | maintenance
guests
id, event_id, name, assigned_category, is_vip, is_close_relative, special_requests
Tags stored inline
stay_segments
id, guest_id, hotel_id, room_id, check_in_at, check_out_at
Multiple per guest; tracks full movement history
service_charges
id, guest_id, type_id, amount, logged_at
Timestamped; editable until bill locked
service_types
id, event_id, name
Configurable per event
checkout_undo_windows
guest_id, checkout_at, expires_at
Checked on app resume; drives 5-min countdown
4. Excel Export: Syncfusion Flutter XlsIO
The export requirement specifies formatted .xlsx output with branding, merged cells, and summary rows. Only Syncfusion Flutter XlsIO supports this at production quality in Flutter.
4.1 Library Comparison
Library
Merged Cells
Styling/Branding
Summary Formulas
Verdict
Syncfusion XlsIO
✅ Yes
✅ Yes
✅ Yes
✅ Selected
excel (pub.dev)
❌ No
Limited
❌ No
❌ Too limited
flutter_xlsio (Syncfusion free)
✅ Yes
✅ Yes
✅ Yes
Same package, free tier
4.2 Licensing
Syncfusion Community License is free for individuals and companies with annual revenue under $1M USD
For revenue above $1M, a paid license is required — budget accordingly
License check should be done before production release
4.3 Report Types to Implement
Report
Sheets
Special Formatting
Per-guest itemized bill
1 sheet per guest or consolidated
Merged header rows, service line items, total row
Per-hotel billing summary
1 sheet per hotel
Room-level grouping, subtotals
Consolidated event billing
Summary + detail sheets
Cross-hotel totals, category breakdowns
Guest movement & room history
One sheet
Chronological stay segments per guest
5. State Management: Riverpod
Riverpod is the selected state management solution. For a single-user, offline, local-data app, it provides the right level of capability without unnecessary complexity.
5.1 Why Riverpod
Providers are globally accessible without requiring BuildContext — simplifies deep widget trees
StateNotifierProvider and StreamProvider pair naturally with Drift's reactive stream queries
Fully testable — providers can be overridden in tests without mocking BuildContext
No boilerplate event/state classes unlike BLoC — appropriate for this app's scope
5.2 What Not To Use
BLoC: Overkill — adds boilerplate without benefit at this scale and user count (1 user)
GetX: Opinionated anti-patterns that hurt maintainability long-term
setState only: Will not scale cleanly across 15 screens with shared state (room availability, running bill)
6. App Architecture
6.1 Feature-First Folder Structure
lib/
  features/
    events/          → event setup, duplication, home list
    hotels/          → hotel setup, room inventory
    guests/          → guest list, check-in, transfer, checkout
    billing/         → service logging, bill view
    export/          → report generation, share sheet
    dashboard/       → summary cards, filters
  data/
    database/        → Drift DB definition, DAOs
    repositories/    → business logic, query assembly
  shared/            → widgets, theme, utilities
6.2 Layer Responsibilities
Layer
Responsibility
Technology
UI (Screens/Widgets)
Render state, dispatch user actions
Flutter widgets, Riverpod Consumer
Providers
Hold and expose state, call repositories
Riverpod StateNotifier / AsyncNotifier
Repositories
Business logic, data aggregation
Plain Dart classes
DAOs
Database queries only — no business logic
Drift DAOs
Database
Schema, migrations, SQLite engine
Drift + SQLite
7. Critical Implementation Notes
These are non-obvious implementation requirements derived from the PRD that will cause bugs if not addressed upfront.
⚠ Undo Checkout — Use Persistent Timer, Not In-Memory
The 5-minute undo window must survive app backgrounding. Store checkout_at and expires_at in the checkout_undo_windows table at the moment of checkout. On every app resume, query expired windows and lock bills automatically. Never implement this with Future.delayed — it will not fire if the app is backgrounded or killed.
⚠ Guest List Rendering — Paginate or Use ListView.builder
Up to 2000 guests must not be loaded into a ListView as a full list. Use ListView.builder (lazy rendering) and paginate Drift queries with limit/offset. Loading all 2000 rows at once will cause frame drops on the Guest List and Dashboard screens.
⚠ Excel Generation — Run in Isolate
Generating a consolidated report for a large event (2000 guests, full history, multiple sheets) can take 2-5 seconds. Run Syncfusion XlsIO generation in a Dart isolate using compute(). Display a progress indicator. Blocking the UI thread will trigger ANR-equivalent freezes.
⚠ CSV/Excel Guest Import — Validate Before Committing
Real-world Excel guest lists from event coordinators are messy. Build a preview and validation step between file selection and database write. Surface errors (missing room category, duplicate names, unrecognized columns) before any data is committed. The PRD does not specify this screen but it is essential.
8. Package Dependencies
Package
Purpose
License / Cost
drift + drift_flutter
SQLite ORM, DAOs, migrations
MIT — Free
riverpod / flutter_riverpod
State management
MIT — Free
syncfusion_flutter_xlsio
Excel export with formatting
Free under $1M revenue
file_picker
CSV/Excel import from device
MIT — Free
csv
Parse CSV guest list files
MIT — Free
share_plus
Native share sheet (WhatsApp, AirDrop, email)
BSD — Free
path_provider
Local file system access for DB and exports
BSD — Free
intl
Date/time formatting throughout app
BSD — Free
8.1 Intentionally Excluded
No HTTP client — no network calls anywhere in the app
No Firebase or any analytics SDK — zero external data transmission
No GetIt or injectable — Riverpod handles DI
No crash reporting SDK — keep dependency surface minimal
9. Out of Scope (Confirmed)
The following are explicitly excluded and must not be designed into the architecture, as they would add maintenance burden without product requirement.
Item
Status
Internet connectivity or backend
Out of scope — no network stack to be added
Authentication or roles
Out of scope — single user, no login
Cloud backup or sync
Out of scope — local storage only
Web app
Out of scope
Hotel PMS integration
Out of scope
Payment processing
Out of scope
Push notifications
Out of scope
Guest-facing portal
Out of scope
Atithi GLMS — Technical Architecture Specification  |  Confidential
